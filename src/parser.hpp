
#ifndef __PARSER_H
#define __PARSER_H

#include "definitions.hpp"
#include "statistics.hpp"
#include "gatetypes.hpp"

using std::to_string;

namespace QuaSARQ {

    enum CircuitMode { RANDOM_CIRCUIT, PARSED_CIRCUIT };

    #define WRITE_STATS(GATE) \
        stream += comment + "\t\t" + string(#GATE) + ": " + to_string(stats.circuit.gate_stats.types[GATE]) + " \t"; \
        stream += "(%" + to_string((uint64)percent((double)stats.circuit.gate_stats.types[GATE], stats.circuit.num_gates)) + ")\n"; \

    static const char *G2S_STIM[] = {
        FOREACH_GATE(GATE2STR)
    };

    struct ParsedGate {
        qubit_t c, t;
        byte_t type;

        ParsedGate(const qubit_t& c, const qubit_t& t, const byte_t& type) :
            c(c), t(t), type(type) {}
    };

    class CircuitQueue : public Vec<ParsedGate, size_t> {

        size_t head;

    public:

        CircuitQueue() : head(0) { }

        bool empty() const {
            return head == size();
        }

        const ParsedGate& front() {
            assert(head < size());
            return operator[](head);
        }

        void pop_front() { ++head; }

        void clear(const bool& free = false) {
            Vec<ParsedGate, size_t>::clear(free);
            head = 0;
        }
    };

    struct CircuitIO {

        #define DELIM '\n'
        #define UNIX_DELIM '\r'
        #define MAX_GATENAME_LEN 16

        void* buffer;
        char* eof;
        size_t size, max_qubits;
        Gate_stats gate_stats;
        CircuitQueue circuit_queue;
        bool measuring;

#if defined(__linux__) || defined(__CYGWIN__)
        int file;
#else
        ifstream file;
#endif

        CircuitIO() :
            buffer(nullptr)
            , eof(nullptr)
            , size(0)
            , max_qubits(0)
            , measuring(false)
        { 
            init();
        }

        ~CircuitIO() { destroy(); }

        void init() {
            circuit_queue.reserve(MB);
            gate_stats.alloc();
        }

        void destroy() {
            circuit_queue.clear(true);
            gate_stats.destroy();
            if (buffer != nullptr) {
#if defined(__linux__) || defined(__CYGWIN__)
                if (munmap(buffer, size) != 0)
                    LOGERROR("cannot clean file mapping.");
#else
                std::free(buffer);
#endif
            }
            buffer = nullptr;
            eof = nullptr;
            size = 0;
            max_qubits = 0;
            measuring = false;
        }

        void write_circuit(string& stream, const int& format, const size_t& num_qubits_in_circuit, const Circuit& circuit) {
            size_t max_depth = circuit.depth();
            for (depth_t d = 0; d < max_depth; d++) {
                const Window& gate_refs = circuit[d];
                const size_t max_refs = gate_refs.size();
                for (size_t i = 0; i < max_refs; i++) {
                    gate_ref_t gate_ref = NO_REF;
                    const Gate* gate = nullptr;
                    gate_ref = gate_refs[i];
                    gate = circuit.gateptr(gate_ref);
                    if (gate->type == byte_t(I)) continue;
                    string gatestr = string(G2S_STIM[gate->type]);
                    if (format == 2) {
                        if (gatestr == "CX") 
                            gatestr = "C";
                        else if (gatestr == "S")
                            gatestr = "P";
                    }
                    stream += gatestr + " " + to_string(gate->wires[0]);
                    if (gate->size > 1)
                        stream += " " + to_string(gate->wires[1]);
                    stream += "\n";        
                }
            }
        }

        void write(const Circuit& circuit, const size_t& num_qubits_in_circuit, const int& format, const Statistics& stats) {
            size_t max_qubits = num_qubits_in_circuit;
            size_t max_depth = circuit.depth();
            string path = "q" + to_string(max_qubits) + "_d" + to_string(max_depth);
            if (format == 1) path += ".stim";
            else if (format == 2) path += ".chp";
            FILE* benchfile = nullptr;
            if (benchfile == nullptr) {
                LOGN2(1, "Opening \"%s%s%s\" circuit file for writing..", CREPORTVAL, path.c_str(), CNORMAL);
                benchfile = fopen(path.c_str(), "w");
                if (benchfile == nullptr) { LOG2(1, "does not exist."); }
                LOGDONE(1, 3);
            }
            LOGN2(1, "Writing circuit with %s%zd qubits%s and %s%zd depth%s..", CREPORTVAL, max_qubits, CNORMAL, CREPORTVAL, max_depth, CNORMAL);
            string comment;
            if (format == 1) comment = "#";
            else if (format == 2) comment = "";
            string stream = comment + "This circuit is generated by QuaSARQ for benchmarking purposes.\n";
            stream += comment + "q" + to_string(max_qubits) + "\n";
            stream += comment + "d" + to_string(max_depth) + "\n";
            stream += comment + "Gates distribution:\n";
            FOREACH_GATE(WRITE_STATS);
            if (format == 2) stream += "#\n";
	        write_circuit(stream, format, num_qubits_in_circuit, circuit);
            fwrite(stream.c_str(), 1, stream.size(), benchfile);
            LOGDONE(1, 3);
            if (benchfile != nullptr) {
                fclose(benchfile);
                benchfile = nullptr;
            }
        }

        inline Gatetypes translate_gate(char* in, const int& gatelen) {
            for (int i = 0; i < NR_GATETYPES; i++) {
                const char* ref = G2S_STIM[i];
                int c = 0;
                while (ref[c]) {
                    if (ref[c] != in[c])
                        break;
                    c++;
                }
                if (gatelen == c)
                    return Gatetypes(i);
            }
            LOGERROR("unknown gate %s.", in);
        }

        char* read(const char* circuit_path) {
            if (circuit_path == nullptr)
                LOGERROR("circuit path is empty.");        
            struct stat st;
            if (!canAccess(circuit_path, st))
                LOGERROR("circuit file is inaccessible.");
            size = st.st_size;
            LOG2(1, "Parsing circuit file \"%s%s%s\" (size: %s%zd%s MB)..", CREPORTVAL, circuit_path, CNORMAL, CREPORTVAL, ratio(size, MB), CNORMAL);
            char* stream = NULL;
#if defined(__linux__) || defined(__CYGWIN__)
            file = open(circuit_path, O_RDONLY, 0);
            if (file == -1) LOGERROR("cannot open input file");
            buffer = mmap(NULL, size, PROT_READ, MAP_PRIVATE, file, 0);
            stream = static_cast<char*>(buffer);
            close(file);
#else
            file.open(circuit_path, ifstream::in);
            if (!file.is_open()) LOGERROR("cannot open input file.");
            stream = calloc<char>(size + 1);
            buffer = static_cast<void*>(stream);
            file.read(stream, size);
            stream[size] = '\0';
            file.close();
#endif
            eof = stream + size;
            return stream;
        }

        void read_gate(char*& str) {
            eatWS(str);
            char gatestr[MAX_GATENAME_LEN];
            int gatename_len = 0;
            while ((isalpha(str[gatename_len]) || str[gatename_len] == '_') && gatename_len < MAX_GATENAME_LEN) {
                gatestr[gatename_len] = str[gatename_len];
                gatename_len++;
            }
            if (gatename_len == MAX_GATENAME_LEN)
                LOGERROR("gate name is too long.");
            gatestr[gatename_len] = '\0';           
            Gatetypes type = translate_gate(gatestr, gatename_len);
            // Flag measurement existance.
            if (type == M) measuring = true;
            str += gatename_len;    
            while (*str != DELIM && str < eof) {   
                if (*str == UNIX_DELIM) { 
                    str++;
                    continue;
                }
				const qubit_t c = toInteger(str);
                max_qubits = MAX(max_qubits, c);
                qubit_t t = c;
				if (gatename_len > 1 && type != S_DAG) {
                    t = toInteger(str);
                    max_qubits = MAX(max_qubits, t);
                }
                circuit_queue.push(ParsedGate(c, t, type));
                gate_stats.types[type]++;
            }
        }

    };

}

#endif
